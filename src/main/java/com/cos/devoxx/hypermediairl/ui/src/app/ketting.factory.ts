import { Injectable } from '@angular/core';
import { Ketting, ShortCache, State } from 'ketting';
import { StateCache } from 'ketting/dist/cache';

@Injectable({providedIn: 'root'})
export class KettingFactory {

  private readonly apiRootUrl;

  constructor() {
    this.apiRootUrl = 'http://localhost:8080/';
  }

  build(): Ketting {
    return new AppKetting(this.apiRootUrl);
  }
}

class AppKetting extends Ketting {

  constructor(private readonly bookMark: string) {
    super(bookMark);
    this.use(this.fetch.bind(this));
    this.cache = new EmbeddedOnlyShortCache(1000);
  }

  async fetch(request: Request, next: (request: Request) => Promise<Response>): Promise<Response> {
    const response = await next(request);
    return this.handleResponse(request, response);
  }

  private async handleResponse(request: Request, response: Response) {
    if (response.status === 401) {
      return response;
    }
    if (response.status === 403) {
      await alert('Access denied');
      return response;
    }
    if (response.status < 400 && response.status !== 200 && ['PUT', 'POST', 'PATCH', 'DELETE'].includes(request.method)) {
      console.info('Les modifications ont été prises en compte');
      return response;
    }
    if (response.status === 404) {
      // 404 is part of the classic flow, so we can't intercept it too soon
      return response;
    }
    if (response.headers.get('Content-Type') === 'application/problem+json') {
      const problemDetails: ProblemDetails = await response.json();
      await alert(problemDetails.detail!);
      return response;
    }

    if (response.status >= 400) {
      const errorMessage = await response.text();
      if (errorMessage && errorMessage.indexOf('{') !== 0) {
        alert(`${errorMessage}`);
      } else {
        alert(`Error ${response.status}`);
      }
      return response;
    }
    return response;
  }
}


/**
 * We want zero client side caching, but we don't want to have to fetch each
 * embedded state in a separate http request.
 * Until https://github.com/badgateway/ketting/issues/297 is fixed, this Ketting
 * cache implementation will make distinction between embedded and non embedded
 * states. Embedded states will be cached for a very short time while no
 * caching will happen for non embedded states.
 *
 * This implementation is not perfect because segmentation is made during cache
 * write only.
 * When the cache is asked for a state, the former has no way to know if
 * the call is made in the context of the embedding states or not.
 *
 * Ideally, Ketting would have 2 types of cache. One dedicated to non embedded states
 * would be implemented by a single global instance.
 * Another dedicated to embedded states would be implemented by one instance
 * per embedding state.
 */
class EmbeddedOnlyShortCache implements StateCache {

  private readonly delegate: StateCache;

  constructor(cacheTimeoutInMs: number) {
    this.delegate = new ShortCache(cacheTimeoutInMs);
  }

  clear(): void {
    this.delegate.clear();
  }

  delete(uri: string): void {
    this.delegate.delete(uri);
  }

  get(uri: string): State | null {
    return this.delegate.get(uri);
  }

  has(uri: string): boolean {
    return this.delegate.has(uri);
  }

  store(state: State): void {
    //TODO remove once https://github.com/badgateway/ketting/issues/400 resolved
    if (state.headers.get('preference-applied') === 'return=minimal') {
      return;
    }
    state
      .getEmbedded()
      .forEach(embeddedState => {
        //TODO remove once https://github.com/badgateway/ketting/issues/400 resolved
        if (embeddedState.headers.get('preference-applied') === 'return=minimal') {
          return;
        }
        this.delegate.store(embeddedState);
      });
  }

}

export interface ProblemDetails {
  /**
   * A URI reference [RFC3986] that identifies the
   * problem type.  This specification encourages that, when
   * dereferenced, it provide human-readable documentation for the
   * problem type (e.g., using HTML [W3C.REC-html5-20141028]).  When
   * this member is not present, its value is assumed to be
   * "about:blank".
   */
  type?: string;
  /**
   * A short, human-readable summary of the problem
   * type.  It SHOULD NOT change from occurrence to occurrence of the
   * problem, except for purposes of localization (e.g., using
   * proactive content negotiation; see [RFC7231], Section 3.4).
   */
  title?: string;
  /**
   * The HTTP status code ([RFC7231], Section 6)
   * generated by the origin server for this occurrence of the problem.
   */
  status?: number;
  /**
   * A human-readable explanation specific to this
   * occurrence of the problem.
   */
  detail?: string;
  /**
   * A URI reference that identifies the specific
   * occurrence of the problem.  It may or may not yield further
   * information if dereferenced.
   */
  instance?: string;
}
